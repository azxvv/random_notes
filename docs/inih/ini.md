# INI

**inih（INI Not Invented Here）**是一个简单的.INI文件用C编写的解析器。它只需要几页代码，而且设计得又小又简单，因此适用于嵌入式系统。

它也或多或少与Python的[ConfigParser](http://docs.python.org/library/configparser.html)风格兼容。INI文件，包括RFC 822风格的多行语法和“name:value”条目。

要使用它，只需给**ini_parse（）**一个ini文件，它就会为解析的每个**name=value**对调用一个回调，为您提供节、名称和值的字符串。

这样做（“SAX风格”）是因为它在低内存嵌入式系统上运行良好，但也因为它有助于KISS实现。

您还可以调用**ini_parse_file（）**直接从**file***对象解析，调用**ini-parse_string（）**从字符串解析数据，或调用**inioparse_stream（）**使用自定义I/O的自定义**fgets**样式读取器函数解析。


## 编译时选项

您可以使用预处理器定义来控制inih的各个方面：
### 语法选项 ###

* **多行条目：**默认情况下，inih支持Python ConfigParser风格的多行条目。要禁用，请添加**-DINI_ALLOW_MULTILINE=0**。
* **UTF-8 BOM：**默认情况下，inih允许在INI文件的开头使用UTF-8 BOM序列（**0xEF 0xBB 0xBF**）。要禁用，请添加**-DINI_ALLOW_BOM=0**。
* **内联注释：**默认情况下，inih允许使用**；**。要禁用，请添加**-DINI_ALLOW_INLINE_COMMENTS=0**。您还可以使用**INI_inline_comment_PREFIXES**指定哪个字符开始内联注释。
* **行首注释：**默认情况下，inih允许两者都使用**；**使用**#**在行首开始注释。您可以通过更改**INI_START_COMMENT_PREFIXES**来覆盖此设置。
* **不允许有值：**默认情况下，inih将没有值的名称（行上没有**=**或**：**）视为错误。要允许没有值的名称，请添加**-DINI_ALOW_no_VALUE=1**，inih将调用值设置为NULL的处理程序函数。

### 解析选项

* **第一次出错时停止：**默认情况下，inih会在出错后继续解析文件的其余部分。要停止对第一个错误的解析，请添加**-DINI_stop_on_first_error=1**。
* **报告行号：**默认情况下，**ini_handler**回调函数不会接收行号作为参数。如果需要，请添加**-DINI_HANDLER_LINENO=1**。
* **在新节上调用处理程序：**默认情况下，inih只调用每个**name=value**对上的处理程序。要检测新节（例如，INI文件有多个同名节），请添加**-DINI_CALL_HANDLER_ON_new_SECTION=1**。每次遇到新节时，都会调用处理程序函数，将**section**设置为新节名称，但将**name**和**value**设置为NULL。

### 内存选项

* **堆栈与堆：**默认情况下，inih在堆栈上创建固定大小的行缓冲区。要使用`malloc`在堆上进行分配，请指定`-DINI_USE_STACK=0 `。
* **最大行长：**默认最大行长（堆栈或堆）为200字节。要覆盖此内容，请添加类似“-DINI_MAX_LINE=1000”的内容。请注意，`INI_MAX_LINE`必须比最长线多3个（由于`r`、`n`和NUL）。
* **初始malloc大小：**`INI_INTIAL_ALLOC`指定使用堆时的初始malloc尺寸。默认为200字节。
* **允许realloc:**默认情况下，当使用堆（`-DINI_USE_STACK=0 `）时，inih会分配一个固定大小的缓冲区，大小为`INI_INTIAL_ALLOC`字节。如果需要，可以加倍，设置“-DINI_allow_REALLOC=1”。
* **自定义分配器：**默认情况下，使用堆时，使用标准库的`malloc`、`free`和`realloc`函数；要使用自定义分配器，请指定“-DINI_custom_allocator=1”（和“-DINI_use_ACK=0”）。您必须定义并链接名为“ini_malloc”、“ini_free”和（如果设置了“ini_ALLOW_RELOC”）“ini_REALLOC”的函数，这些函数必须与“stdlib.h”内存分配函数具有相同的签名。


## 平台特定注意事项

**Windows/Win32**原生使用UTF-16文件名，因此要处理Unicode路径，您需要调用`_wfopen（）`打开文件，然后调用`ini_parse_file（）`解析它；inih不包括wchar_t或Unicode处理。




-------------------------------------------------------------------------------------
> 以下是笔者注

# SAX 解析风格

 inih 的语境中，SAX 风格指的是一种基于事件驱动的解析方式，其核心特点是边解析边处理数据，而非一次性将整个文件加载到内存中再进行处理。

具体来说，SAX（Simple API for XML）是一种经典的 XML 解析模型，后来也被引申到其他格式的解析中（如 INI 文件）。它的工作流程如下：

    解析器逐行读取文件内容，当识别到特定结构（如 INI 文件中的 “节”“键值对”）时，会立即调用预设的回调函数（回调函数由使用者定义），并将解析到的信息（如节名、键名、值）作为参数传递给回调函数。
    使用者通过在回调函数中编写逻辑，实时处理这些数据（例如存储到变量、验证格式等）。
    解析过程中不会在内存中保存整个文件的结构或数据，解析完成后也不会生成一个可供随机访问的内存对象（如解析为字典或结构体）。


这种风格在 inih 中的体现是：
当调用ini_parse()等函数解析 INI 文件时，解析器每遇到一个name=value对（或根据配置遇到新的节），就会触发用户提供的回调函数，将节、名称、值等信息传递给该函数。用户需要在回调函数中即时处理这些数据，而解析器本身不会保存这些信息。

SAX 风格的优势：

    内存占用低：尤其适合嵌入式系统等内存有限的场景，因为不需要为整个文件内容分配大量内存。
    解析速度快：无需等待整个文件解析完成即可开始处理数据，适合大型文件。
    实现简单：解析器无需维护复杂的内存数据结构，符合 inih“小巧、简洁” 的设计理念（KISS 原则）。


与之相对的是 “DOM 风格”（Document Object Model），即解析器会将整个文件加载到内存并构建一个完整的数据结构（如树状结构），供使用者后续随机访问和修改。但 DOM 风格内存占用较高，不适合资源受限的环境。





# 多行条目

在 INI 文件格式中，**多行条目**指的是一个配置项的值可以跨越多行书写，而不仅仅局限于一行。这种特性允许配置值包含换行符、长文本或复杂格式的数据。

### 典型用法示例

在 inih 兼容的 Python ConfigParser 风格中，多行条目的语法规则通常是：

- 当一个值以换行符结束时，后续行如果以**缩进**（通常是空格或制表符）开头，则被视为前一行值的延续。
- 延续行的缩进部分会被保留为值的一部分。

例如：

```ini
[Section]
long_text = 第一行内容
  第二行内容（缩进开头，表示是上一行的延续）
  第三行内容
multiline_value = 这是一个包含
  换行符的
  长文本值
```

### 解析后的效果

上述配置在解析后，对应的键值对会被处理为：

- `long_text` 的值是：`"第一行内容\n  第二行内容（缩进开头，表示是上一行的延续）\n  第三行内容"`
- `multiline_value` 的值是：`"这是一个包含\n  换行符的\n  长文本值"`

### 配置与限制

在 inih 中，多行条目的支持是**默认开启**的，但可以通过编译选项禁用：

- 添加 `-DINI_ALLOW_MULTILINE=0` 可禁用此特性，禁用后所有行都将被视为独立的条目。
- 默认最大行长为 200 字节（包含换行符和终止符），可通过 `-DINI_MAX_LINE` 调整。

### 与其他格式的对比

- **标准 INI**：部分 INI 解析器不支持多行值，只能通过转义字符（如`\n`）模拟换行。
- **Python ConfigParser**：支持类似的多行语法，但延续行必须以空格或制表符开头。
- **JSON/YAML**：通过显式的多行语法（如 YAML 的`|`或`>`）实现更灵活的多行文本。

### 适用场景

多行条目特别适合配置：

- 包含换行符的文本（如 SQL 查询、脚本代码）
- 路径列表或 URL 列表
- 注释较多的配置项
- 无需转义特殊字符的长文本

在嵌入式系统中，多行条目的支持需要权衡内存使用和配置灵活性，这也是 inih 提供编译选项控制该特性的原因。







# UTF-8 BOM

一般情况下，UTF-8 编码的文件可以不使用 BOM，尤其是在 Unix/Linux 系统环境中，通常使用无 BOM 的 UTF-8  文件。但在一些特定场景，如需要与某些 Windows 程序保持兼容性，或明确需要标识文件编码格式时，可以使用带 BOM 的 UTF-8 编码。









